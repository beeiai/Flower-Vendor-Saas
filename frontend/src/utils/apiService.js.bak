const BACKEND_URL = import.meta.env.VITE_API_BASE_URL;
if (!BACKEND_URL) {
  throw new Error("VITE_API_BASE_URL is not defined");
}
// Ensure we target the backend API base (mount routers under /api, no trailing slash)
const BACKEND_API = (function () {
  try {
    const u = String(BACKEND_URL || '').replace(/\/+$/,'');
    return u.endsWith('/api') ? u : `${u}/api`;
  } catch {
    return `${BACKEND_URL}/api`;
  }
})();

const AUTH_TOKEN_KEY = 'skfs_auth_token';
const USER_DATA_KEY = 'skfs_user_data';

function safeParseJson(text) {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

async function handleResponse(res) {
  if (!res.ok) {
    const text = await res.text();
    const details = safeParseJson(text) || null;
    const message =
      (details && (details.detail || details.message || details.error)) ||
      `Request failed: ${res.status}`;
    const err = new Error(message);
    err.status = res.status;
    err.details = details;
    if (!res.status) {
      err.isNetworkError = true;
    }
    throw err;
  }

  if (res.status === 204) return null;
  const text = await res.text();
  if (!text) return null;
  return safeParseJson(text);
}

function getAuthToken() {
  try {
    return window.localStorage.getItem(AUTH_TOKEN_KEY);
  } catch {
    return null;
  }
}

function setAuthToken(token) {
  try {
    if (!token) {
      window.localStorage.removeItem(AUTH_TOKEN_KEY);
    } else {
      window.localStorage.setItem(AUTH_TOKEN_KEY, token);
    }
  } catch {
    // ignore storage errors (e.g. private mode)
  }
}

function getUserData() {
  try {
    const raw = window.localStorage.getItem(USER_DATA_KEY);
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

function setUserData(data) {
  try {
    if (!data) {
      window.localStorage.removeItem(USER_DATA_KEY);
    } else {
      window.localStorage.setItem(USER_DATA_KEY, JSON.stringify(data));
    }
  } catch {
    // ignore
  }
}

function clearAuth() {
  setAuthToken(null);
  setUserData(null);
}

// Check if a token exists, but don't validate it
function isAuthenticated() {
  return Boolean(getAuthToken());
}

function normalizeBackendPath(path) {
  let p = String(path || '');
  // always ensure a single leading slash (BACKEND_API already has no trailing slash)
  if (!p.startsWith('/')) p = `/${p}`;
  // ensure trailing slash for non-auth collection-style endpoints to avoid 307 redirects
  // but exclude silk ledger endpoint which expects no trailing slash
  if (!p.endsWith('/')) {
    // keep /auth endpoints as-is; FastAPI handles both, but avoid surprises
    if (!p.startsWith('/auth') && !p.includes('/silk/ledger')) {
      p = `${p}/`;
    }
  }
  return p;
}

async function backendRequest(path, { method = 'GET', body, auth = false } = {}) {
  const headers = {};
  let payload = body;

  if (body && !(body instanceof FormData)) {
    headers['Content-Type'] = 'application/json';
    payload = JSON.stringify(body);
  }

  if (auth) {
    const token = getAuthToken();
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
  }

  const normalizedPath = normalizeBackendPath(path);
  const res = await fetch(`${BACKEND_API}${normalizedPath}`, {
    method,
    headers,
    body: payload,
  });

  return handleResponse(res);
}

export const authApi = {
  /**
   * Login against FastAPI backend using OAuth2PasswordRequestForm
   */
  async login(email, password) {
    const form = new URLSearchParams();
    form.set('username', email);
    form.set('password', password);
    // grant_type is optional for FastAPI's OAuth2PasswordRequestForm; keep empty for password flow.
    form.set('grant_type', '');

    const res = await fetch(`${BACKEND_API}/auth/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: form.toString(),
    });

    const data = await handleResponse(res);

    if (data?.access_token) {
      setAuthToken(data.access_token);
    }

    return data;
  },

  /**
   * Register against FastAPI backend
   */
  async register(payload) {
    return backendRequest('/auth/register', {
      method: 'POST',
      body: payload,
    });
  },

  /**
   * Signup against FastAPI backend (legacy)
   */
  async signup(payload) {
    return backendRequest('/auth/signup', {
      method: 'POST',
      body: payload,
    });
  },

  /**
   * Clear client-side auth state
   */
  logout() {
    clearAuth();
  },

  /**
   * Fetch current user from backend using stored token
   */
  me() {
    return backendRequest('/auth/me', { auth: true });
  },
};

export {
  getAuthToken,
  getUserData,
  setUserData,
  clearAuth,
  isAuthenticated,
  backendRequest,
};
